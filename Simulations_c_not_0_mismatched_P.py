import numpy as np
import torch
import gc
from Restricted_Boltzmann_machine_training import RBM, build_m_diag_range

import matplotlib.pyplot as plt

plt.rcParams["font.family"] = "serif"
plt.rcParams["mathtext.fontset"] = "dejavuserif"

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

'''
beta = 1.2

n_alpha = 20
alpha_range = np.linspace(0.1, 1, num = n_alpha, endpoint = True)

N = 512
P = 2
P_t = P + 1
m_0 = 0.
c = 0.3

# It is very fast to sample from the teacher
number_teacher_sampling_steps = 100
number_monitored_sampling_steps = 10

number_student_training_epochs = 36*12000
number_monitored_training_epochs = 20
number_burn_in_epochs = 108000
number_magnetization_samples = 1000

random_number_seed = 37

random_batch_seed = 87
'''

def simulation_run_mismatched_P(beta, alpha_range, c, N, P, P_t, m_0, number_teacher_sampling_steps,
                    number_monitored_sampling_steps, number_student_training_epochs,
                    number_monitored_training_epochs, number_burn_in_epochs,
                    number_magnetization_samples, random_number_seed, random_batch_seed):
    '''
    Train a binary student RBM on data generated by a binary teacher RBM for a range of loads alpha
    in order to reproduce Fig. (10).
    The teacher and student have the same number of visible units N.
    The teacher has P hidden units, while the students have P_t hidden units.
    See Restricted_Boltzmann_machine_training.py for the definition of the RBM class
    and the inputs of this function.
    The results are saved in .npy files.
    '''
    n_alpha = len(alpha_range)

    random_number_generator = torch.Generator(device = device)
    random_number_generator.manual_seed(random_number_seed)

    random_batch_generator = torch.Generator(device = "cpu")
    random_batch_generator.manual_seed(random_batch_seed)

    mat_cor = (1 - c) * torch.eye(P, P) + c * torch.ones((P, P))
    teacher = RBM(N, P, device = device, random_number_generator = random_number_generator,
                random_batch_generator = random_batch_generator).to(device)
    xi_s = teacher.initialize_weights(1., xi_0 = None, binarize = True, mat_cor = torch.sin(np.pi/2 * mat_cor).to(device))

    student = RBM(N, P_t, device = device, random_number_generator = random_number_generator,
                random_batch_generator = random_batch_generator, teacher = teacher).to(device)
    student.initialize_weights(m_0, xi_0 = xi_s, P = P, binarize = True, bias_corner = False)

    field = torch.zeros_like(student.xi)

    m_mean_range = np.zeros(n_alpha)
    m_std_range = np.zeros(n_alpha)

    for i, alpha in enumerate(alpha_range):
        M = int(alpha*N)
        beta_eff = beta/N**(1/2)
        
        N_batch_size = 1
        
        sigma = torch.nn.Parameter(torch.sign(torch.randn((M, N), device = device, generator = random_number_generator)), requires_grad = False)
        
        teacher.gibbs_sample_visible(sigma, beta_eff, number_teacher_sampling_steps, number_monitored_sampling_steps)
        
        m_list = student.metropolis_training(sigma, field, beta_eff, number_student_training_epochs, N_batch_size, number_monitored_training_epochs,
                                            number_burn_in_epochs, number_magnetization_samples, anneal = False)
        
        m_range = np.abs(np.array(m_list))
        
        m_range = build_m_diag_range(m_range)
        
        m_mean_range[i] = np.mean(m_range)
        m_std_range[i] = np.std(m_range)
        
        del sigma
        
        # Reinitialize weights
        student.initialize_weights(m_0, xi_0 = xi_s, P = P, binarize = True, bias_corner = False)

    with open("./Data/simulated_magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "wb") as file:
        np.save(file, m_mean_range)
        np.save(file, m_std_range)

    del teacher
    del student

    gc.collect()

def plot_simulated_block_PS_overlap(beta, alpha_range, P, P_t, c_range):
    '''
    Load the magnetization from .npy files written by the function simulation_run_mismatched_P
    and compare it to the prediction of the saddle-point equations in order to reproduce Fig. (10).
    '''
    fig, axes = plt.subplots(nrows = 1, ncols = 3, sharex = False, sharey = "row", figsize = (15, 6))
    
    fig_axis = fig.add_subplot(111, frameon = False)
    plt.tick_params(labelcolor = "none", which = "both", top = False, bottom = False, left = False, right = False)
    
    fontsize = 19
    
    display_legend = True
    for c, axis in zip(c_range, axes):
        with open("./Data/aligned_block_PS_magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
            m_aligned = np.load(file)
        
        with open("./Data/anti_aligned_block_PS_magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
            m_anti_aligned = np.load(file)
        
        try:
            with open("./Data/simulated_magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
                m_mean_range = np.load(file)
                m_std_range = np.load(file)
            plot_simulation_data = True
        except FileNotFoundError:
            plot_simulation_data = False
        
        axis.plot(alpha_range, m_aligned, color = "C1", label = r"Aligned PS blocks")
        axis.plot(alpha_range, m_anti_aligned, color = "C2", label = r"Anti-aligned PS blocks")
        if display_legend:
            axis.legend(fontsize = fontsize)
            display_legend = False
        
        if plot_simulation_data:
            axis.errorbar(alpha_range, m_mean_range, m_std_range, marker = "o", linestyle = "--", capsize = 3, zorder = 2.5, color = "C0")
        axis.tick_params(axis = "both", which = "both", labelsize = fontsize)
        
        axis.set_title(r"Correlation $c = %.2f$" % c, fontsize = fontsize)
        
    fig_axis.set_xlabel(r"Load $\alpha$", fontsize = fontsize, labelpad = 15)
    fig_axis.set_ylabel(r"Magnetization $m$", fontsize = fontsize, labelpad = 15)
    plt.tight_layout()
    plt.show()

def plot_simulated_overlap(beta, alpha_range, P, P_t_range, c):
    '''
    Load the magnetization from .npy files written by the function simulation_run_mismatched_P
    and compare it to the prediction of the saddle-point equations in order to reproduce Fig. (?).
    '''
    fig, axes = plt.subplots(nrows = 1, ncols = 3, sharex = False, sharey = "row", figsize = (15, 6))
    
    fig_axis = fig.add_subplot(111, frameon = False)
    plt.tick_params(labelcolor = "none", which = "both", top = False, bottom = False, left = False, right = False)

    fontsize = 19
    
    for P_t, axis in zip(P_t_range, axes):
        # May need to change the path
        with open("./Data/magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
            m_range = np.load(file)
        
        try:
            with open("./Data/simulated_magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
                m_mean_range = np.load(file)
                m_std_range = np.load(file)
            plot_simulation_data = True
        except FileNotFoundError:
            plot_simulation_data = False
        
        axis.plot(alpha_range, m_range, color = "C1")
        
        if plot_simulation_data:
            axis.errorbar(alpha_range, m_mean_range, m_std_range, marker = "o", linestyle = "--", capsize = 3, zorder = 2.5, color = "C0")
        axis.tick_params(axis = "both", which = "both", labelsize = fontsize)
        
        axis.set_title(r"No. student hidden units $\Tilde{P} = %d$" % P_t, fontsize = fontsize)
        
    fig_axis.set_xlabel(r"Load $\alpha$", fontsize = fontsize, labelpad = 15)
    fig_axis.set_ylabel(r"Magnetization $m$", fontsize = fontsize, labelpad = 15)
    plt.tight_layout()
    plt.show()
    
    plt.errorbar(alpha_range, m_mean_range, m_std_range, marker = "o", linestyle = "--", capsize = 3, zorder = 2.5, color = "C0")
    plt.plot(alpha_range, m_range, color = "C1")
    plt.xlabel(r"Load $\alpha$", fontsize = fontsize)
    plt.ylabel(r"Magnetization $m$", fontsize = fontsize)
    plt.xticks(fontsize = fontsize)
    plt.yticks(fontsize = fontsize)
    plt.tight_layout()
    plt.show()