import numpy as np
import torch
import gc
from Restricted_Boltzmann_machine_training import RBM, build_m_diag_range

import matplotlib.pyplot as plt

plt.rcParams["font.family"] = "serif"
plt.rcParams["mathtext.fontset"] = "dejavuserif"

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

def simulation_run_mismatched_P(beta, alpha_range, c, N, P, P_t, m_0, number_teacher_sampling_steps,
                    number_monitored_sampling_steps, number_student_training_epochs,
                    number_monitored_training_epochs, number_burn_in_epochs,
                    number_magnetization_samples, random_number_seed, random_batch_seed):
    '''
    Train a binary student RBM on data generated by a binary teacher RBM for a range of loads alpha
    in order to reproduce Fig. (10).
    The teacher and student have the same number of visible units N.
    The teacher has P hidden units, while the students have P_t hidden units.
    See Restricted_Boltzmann_machine_training.py for the definition of the RBM class
    and the inputs of this function.
    The results are saved in .npy files.
    '''
    n_alpha = len(alpha_range)

    random_number_generator = torch.Generator(device = device)
    random_number_generator.manual_seed(random_number_seed)

    random_batch_generator = torch.Generator(device = "cpu")
    random_batch_generator.manual_seed(random_batch_seed)

    mat_cor = (1 - c) * torch.eye(P, P) + c * torch.ones((P, P))
    teacher = RBM(N, P, device = device, random_number_generator = random_number_generator,
                random_batch_generator = random_batch_generator).to(device)
    xi_s = teacher.initialize_weights(1., xi_0 = None, binarize = True, mat_cor = torch.sin(np.pi/2 * mat_cor).to(device))

    student = RBM(N, P_t, device = device, random_number_generator = random_number_generator,
                random_batch_generator = random_batch_generator, teacher = teacher).to(device)
    student.initialize_weights(m_0, xi_0 = xi_s, P = P, binarize = True, bias_corner = False)
    
    student.xi[:, 0 : P].copy_(xi_s)
    student.xi[:, P : P_t].copy_(-xi_s[:, 0 : 1].detach())
    # xi[:, P : P_t].copy_((1 - m_0**2)**(1/2) * xi[:, P : P_t] + m_0 * xi_0[:, 0 : 1].detach())
    
    field = torch.zeros_like(student.xi)

    # m_mean_range = np.zeros(n_alpha)
    # m_std_range = np.zeros(n_alpha)
    m_mean_range = np.zeros((n_alpha, 2))
    m_std_range = np.zeros((n_alpha, 2))

    for i, alpha in enumerate(alpha_range):
        M = int(alpha*N)
        beta_eff = beta/N**(1/2)
        
        N_batch_size = 1
        
        sigma = torch.nn.Parameter(torch.sign(torch.randn((M, N), device = device, generator = random_number_generator)), requires_grad = False)
        
        teacher.gibbs_sample_visible(sigma, beta_eff, number_teacher_sampling_steps, number_monitored_sampling_steps)
        
        m_list = student.metropolis_training(sigma, field, beta_eff, number_student_training_epochs, N_batch_size, number_monitored_training_epochs,
                                            number_burn_in_epochs, number_magnetization_samples, anneal = False)
        
        m_range = np.array(m_list)

        m_range_copy = np.copy(m_range)

        m_main_diag = build_m_diag_range(m_range)

        m_main_diag_sum = np.sum(m_main_diag, axis = -1)

        m_mean_range[i, 0] = np.mean(m_main_diag_sum / P)
        m_std_range[i, 0] = np.std(m_main_diag_sum / P)

        m_mean_range[i, 1] = np.mean((np.sum(m_range_copy, axis = (1, 2)) - m_main_diag_sum) / (P*(P - 1)))
        m_std_range[i, 1] = np.std((np.sum(m_range_copy, axis = (1, 2)) - m_main_diag_sum) / (P*(P - 1)))
        
        del sigma
        
        # Reinitialize weights
        student.initialize_weights(m_0, xi_0 = xi_s, P = P, binarize = True, bias_corner = False)

    with open("./Data/simulated_magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "wb") as file:
        np.save(file, m_mean_range)
        np.save(file, m_std_range)

    del teacher
    del student

    gc.collect()

def simulation_distribution_mismatched_P(beta, alpha, c, N, P, P_t, m_0, number_teacher_sampling_steps,
                    number_monitored_sampling_steps, number_student_training_epochs,
                    number_monitored_training_epochs, number_burn_in_epochs,
                    number_magnetization_samples, random_number_seed, random_batch_seed):
    '''
    Train a binary student RBM on data generated by a binary teacher RBM for a specific load alpha
    in order to reproduce Fig. (10).
    The teacher and student have the same number of visible units N.
    The teacher has P hidden units, while the students have P_t hidden units.
    See Restricted_Boltzmann_machine_training.py for the definition of the RBM class
    and the inputs of this function.
    The results are saved in .npy files.
    '''

    random_number_generator = torch.Generator(device = device)
    random_number_generator.manual_seed(random_number_seed)

    random_batch_generator = torch.Generator(device = "cpu")
    random_batch_generator.manual_seed(random_batch_seed)

    mat_cor = (1 - c) * torch.eye(P, P) + c * torch.ones((P, P))
    teacher = RBM(N, P, device = device, random_number_generator = random_number_generator,
                random_batch_generator = random_batch_generator).to(device)
    xi_s = teacher.initialize_weights(1., xi_0 = None, binarize = True, mat_cor = torch.sin(np.pi/2 * mat_cor).to(device))

    student = RBM(N, P_t, device = device, random_number_generator = random_number_generator,
                random_batch_generator = random_batch_generator, teacher = teacher).to(device)
    student.initialize_weights(m_0, xi_0 = xi_s, P = P, binarize = True, bias_corner = False)
    
    # student.xi[:, 0 : P].copy_(xi_s)
    # student.xi[:, P : P_t].copy_(-xi_s[:, 0 : 1].detach())
    # xi[:, P : P_t].copy_((1 - m_0**2)**(1/2) * xi[:, P : P_t] + m_0 * xi_0[:, 0 : 1].detach())
    
    field = torch.zeros_like(student.xi)

    M = int(alpha*N)
    beta_eff = beta/N**(1/2)

    N_batch_size = 1

    sigma = torch.nn.Parameter(torch.sign(torch.randn((M, N), device = device, generator = random_number_generator)), requires_grad = False)

    teacher.gibbs_sample_visible(sigma, beta_eff, number_teacher_sampling_steps, number_monitored_sampling_steps)

    m_list = student.metropolis_training(sigma, field, beta_eff, number_student_training_epochs, N_batch_size, number_monitored_training_epochs,
                                        number_burn_in_epochs, number_magnetization_samples, anneal = False)

    m_range = np.array(m_list)

    del sigma

    with open("./Data/simulated_magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f_alpha=%.2f.npy" % (c, P, P_t, beta, alpha), "wb") as file:
        np.save(file, m_range)

    del teacher
    del student

    gc.collect()

def plot_simulated_block_PS_overlap(beta, alpha_range, P, P_t, c_range):
    '''
    Load the magnetization from .npy files written by the function simulation_run_mismatched_P
    and compare it to the prediction of the saddle-point equations in order to reproduce Fig. (10).
    '''
    fig, axes = plt.subplots(nrows = 1, ncols = 3, sharex = False, sharey = "row", figsize = (15, 6))
    
    fig_axis = fig.add_subplot(111, frameon = False)
    plt.tick_params(labelcolor = "none", which = "both", top = False, bottom = False, left = False, right = False)
    
    fontsize = 19
    
    display_legend = True
    for c, axis in zip(c_range, axes):
        with open("./Data/aligned_block_PS_magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
            m_aligned = np.load(file)
        
        with open("./Data/anti_aligned_block_PS_magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
            m_anti_aligned = np.load(file)
        
        try:
            with open("./Data/simulated_magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
                m_mean_range = np.load(file)
                m_std_range = np.load(file)
            plot_simulation_data = True
        except FileNotFoundError:
            plot_simulation_data = False
        
        axis.plot(alpha_range, m_aligned, color = "C1", label = r"Aligned PS blocks")
        axis.plot(alpha_range, np.abs(m_anti_aligned), color = "C2", label = r"Anti-aligned PS blocks")
        if display_legend:
            axis.legend(fontsize = fontsize)
            display_legend = False
        
        if plot_simulation_data:
            for m_mean_subrange, m_std_subrange in zip(m_mean_range.T, m_std_range.T):
                axis.errorbar(alpha_range, m_mean_subrange, m_std_subrange, marker = "o", linestyle = "--", capsize = 3, zorder = 2.5, color = "C0")
        axis.tick_params(axis = "both", which = "both", labelsize = fontsize)
        
        axis.set_title(r"Correlation $c = %.2f$" % c, fontsize = fontsize)
        
    fig_axis.set_xlabel(r"Load $\alpha$", fontsize = fontsize, labelpad = 15)
    fig_axis.set_ylabel(r"Magnetization $m$", fontsize = fontsize, labelpad = 15)
    plt.tight_layout()
    plt.show()

def plot_individual_overlap(beta, alpha_range, P, P_t, c):
    '''
    Load the magnetization from .npy files written by the function simulation_run_mismatched_P
    and compare it to the prediction of the saddle-point equations in order to reproduce Fig. (?).
    '''
    eps = 0.05
    
    fig, axes = plt.subplots(nrows = 2, ncols = 1, sharex = False, sharey = "row", figsize = (6, 8))
    
    fig_axis = fig.add_subplot(111, frameon = False)
    plt.tick_params(labelcolor = "none", which = "both", top = False, bottom = False, left = False, right = False)

    fontsize = 19
    
    with open("./Data/magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
        m_range = np.load(file)
    
    with open("./Data/overlap_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
        q_range = np.load(file)

    if (P == P_t) and (P_t == 2):
        with open("./Data/simulated_magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
            m_mean_range = np.load(file)
            m_std_range = np.load(file)
    
    # q_res = np.sqrt(q_range[:, 0]) - q_range[:, 1] / np.sqrt(q_range[:, 0])
    # m_res = np.sqrt(m_range[:, 0]) - m_range[:, 1] / np.sqrt(m_range[:, 0])
    q_res = 1 - q_range[:, 1] / q_range[:, 0]
    m_res = 1 - m_range[:, 1] / m_range[:, 0]
    
    alpha_range_P = alpha_range[q_range[:, 0] <= eps]
    alpha_range_SSB = alpha_range[q_res <= eps]
    alpha_range_PS = alpha_range[m_res <= eps]
        
    alpha_SSB = alpha_range_P[-1]
    alpha_PSB_s = alpha_range_SSB[-1]
    alpha_PSB_t = alpha_range_PS[-1]

    axes[0].plot(alpha_range, m_range, color = "C1")

    if (P == P_t) and (P_t == 2):
        for m_mean_subrange, m_std_subrange in zip(m_mean_range.T, m_std_range.T):
            axes[0].errorbar(alpha_range, m_mean_subrange, m_std_subrange, marker = "o", linestyle = "--", capsize = 3, zorder = 2.5, color = "C0")
    axes[0].tick_params(axis = "both", which = "both", labelsize = fontsize)

    # axes[0].set_title(r"No. hidden units $P = %d$, $\tilde{P} = %d$," % (P, P_t) + "\n" + r"Correlation $c = %.2f$" % c, fontsize = fontsize)
    axes[0].set_title(r"No. hidden units $P^* = %d$, $P = %d$" % (P, P_t), fontsize = fontsize)
    
    axes[0].set_ylabel(r"Magnetization $m$", fontsize = fontsize, labelpad = 15)
    
    axes[0].axvline(alpha_SSB, color = "black", zorder = 1.5, linestyle = "--")
    axes[0].axvline(alpha_PSB_s, color = "black", zorder = 1.5, linestyle = "--")
    axes[0].axvline(alpha_PSB_t, color = "black", zorder = 1.5, linestyle = "--")
    
    m_bottom, m_top = axes[0].get_ylim()
    
    axes[0].annotate(r"SSB", (alpha_SSB, 0.77*m_top),
                     fontsize = fontsize, rotation = -90)
    axes[0].annotate(r"$\mathrm{PSB}_{\mathrm{s}}$", (alpha_PSB_s, 0.75*m_top),
                     fontsize = fontsize, rotation = -90)
    axes[0].annotate(r"$\mathrm{PSB}_{\mathrm{t}}$", (alpha_PSB_t, 0.75*m_top),
                     fontsize = fontsize, rotation = -90)
    
    axes[1].plot(alpha_range, q_range, color = "C3")

    axes[1].tick_params(axis = "both", which = "both", labelsize = fontsize)

    axes[1].set_ylabel(r"Overlap $q$", fontsize = fontsize, labelpad = 15)
    
    axes[1].axvline(alpha_SSB, color = "black", zorder = 1.5, linestyle = "--")
    axes[1].axvline(alpha_PSB_s, color = "black", zorder = 1.5, linestyle = "--")
    axes[1].axvline(alpha_PSB_t, color = "black", zorder = 1.5, linestyle = "--")
    
    q_bottom, q_top = axes[1].get_ylim()
    
    axes[1].annotate(r"SSB", (alpha_SSB, 0.77*q_top),
                     fontsize = fontsize, rotation = -90)
    axes[1].annotate(r"$\mathrm{PSB}_{\mathrm{s}}$", (alpha_PSB_s, 0.75*q_top),
                     fontsize = fontsize, rotation = -90)
    axes[1].annotate(r"$\mathrm{PSB}_{\mathrm{t}}$", (alpha_PSB_t, 0.75*q_top),
                     fontsize = fontsize, rotation = -90)
    
    fig_axis.set_xlabel(r"Load $\alpha$", fontsize = fontsize, labelpad = 15)
    plt.tight_layout()
    plt.show()

def plot_simulated_overlap(beta, alpha_range, P_tuple_range, c_range):
    '''
    Load the magnetization from .npy files written by the function simulation_run_mismatched_P
    and compare it to the prediction of the saddle-point equations in order to reproduce Fig. (?).
    '''
    eps_1 = 0.025
    eps_2 = 0.1
    
    fig, axes = plt.subplots(nrows = 2, ncols = 3, sharex = "all", sharey = "row", figsize = (15, 10))
    
    fig_axis = fig.add_subplot(111, frameon = False)
    plt.tick_params(labelcolor = "none", which = "both", top = False, bottom = False, left = False, right = False)

    fontsize = 19
    
    for c, P_tuple, axis in zip(c_range, P_tuple_range, axes[0]):
        P, P_t = P_tuple
        with open("./Data/magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
            m_range = np.load(file)
        
        with open("./Data/overlap_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
            q_range = np.load(file)
        
        q_res = 1 - q_range[:, 1] / q_range[:, 0]
        m_res = 1 - m_range[:, 1] / m_range[:, 0]

        alpha_range_P = alpha_range[m_range[:, 0] <= eps_1]
        alpha_range_SSB = alpha_range[q_res <= eps_1]
        alpha_range_PS = alpha_range[m_res <= eps_2]

        alpha_SSB = alpha_range_P[-1]
        alpha_PSB_s = alpha_range_SSB[-1]
        alpha_PSB_t = alpha_range_PS[-1]
        
        try:
            with open("./Data/simulated_magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
                m_mean_range = np.load(file)
                m_std_range = np.load(file)
            plot_simulation_data = True
        except FileNotFoundError:
            plot_simulation_data = False
        
        axis.plot(alpha_range, m_range, color = "C1")
        axis.scatter(2.4, 0.345, color = "black", marker = "+", zorder = 3, s = 90, linewidth = 3)
        
        if plot_simulation_data:
            for m_mean_subrange, m_std_subrange in zip(m_mean_range.T, m_std_range.T):
                axis.errorbar(alpha_range, m_mean_subrange, m_std_subrange, marker = "o", linestyle = "--", capsize = 3, zorder = 2.5, color = "C0")
        
        axis.axvline(alpha_SSB, color = "black", zorder = 1.5, linestyle = "--")
        axis.axvline(alpha_PSB_s, color = "black", zorder = 1.5, linestyle = "--")
        axis.axvline(alpha_PSB_t, color = "black", zorder = 1.5, linestyle = "--")
        
        m_bottom, m_top = axis.get_ylim()
        
        axis.annotate(r"SSB", (alpha_SSB, 0.77*m_top),
                         fontsize = fontsize, rotation = -90)
        axis.annotate(r"$\mathrm{PSB}_{\mathrm{s}}$", (alpha_PSB_s, 0.75*m_top),
                         fontsize = fontsize, rotation = -90)
        axis.annotate(r"$\mathrm{PSB}_{\mathrm{t}}$", (alpha_PSB_t, 0.75*m_top),
                         fontsize = fontsize, rotation = -90)
        
        axis.tick_params(axis = "both", which = "both", labelsize = fontsize)
        
        # axis.set_title(r"No. hidden units $P = %d$, $\tilde{P} = %d$," % P_tuple + "\n" + r"Correlation $c = %.2f$" % c, fontsize = fontsize)
        axis.set_title(r"Correlation $c = %.2f$" % c, fontsize = fontsize)
    
    axes[0, 0].set_ylabel(r"Magnetization $m$", fontsize = fontsize, labelpad = 15)
    
    for c, P_tuple, axis in zip(c_range, P_tuple_range, axes[1]):
        P, P_t = P_tuple
        with open("./Data/magnetization_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
            m_range = np.load(file)
        
        with open("./Data/overlap_c=%.2f_P=%d_P_t=%d_beta=%.2f.npy" % (c, P, P_t, beta), "rb") as file:
            q_range = np.load(file)
        
        q_res = 1 - q_range[:, 1] / q_range[:, 0]
        m_res = 1 - m_range[:, 1] / m_range[:, 0]

        alpha_range_P = alpha_range[m_range[:, 0] <= eps_1]
        alpha_range_SSB = alpha_range[q_res <= eps_1]
        alpha_range_PS = alpha_range[m_res <= eps_2]

        alpha_SSB = alpha_range_P[-1]
        alpha_PSB_s = alpha_range_SSB[-1]
        alpha_PSB_t = alpha_range_PS[-1]
        
        axis.plot(alpha_range, q_range, color = "C3", zorder = 2.5)
        
        axis.axvline(alpha_SSB, color = "black", zorder = 1.5, linestyle = "--")
        axis.axvline(alpha_PSB_s, color = "black", zorder = 1.5, linestyle = "--")
        axis.axvline(alpha_PSB_t, color = "black", zorder = 1.5, linestyle = "--")
        
        q_bottom, q_top = axis.get_ylim()
        
        axis.annotate(r"SSB", (alpha_SSB, 0.77*q_top),
                         fontsize = fontsize, rotation = -90)
        axis.annotate(r"$\mathrm{PSB}_{\mathrm{s}}$", (alpha_PSB_s, 0.75*q_top),
                         fontsize = fontsize, rotation = -90)
        axis.annotate(r"$\mathrm{PSB}_{\mathrm{t}}$", (alpha_PSB_t, 0.75*q_top),
                         fontsize = fontsize, rotation = -90)
        
        axis.tick_params(axis = "both", which = "both", labelsize = fontsize)
    
    axes[1, 0].set_ylabel(r"Overlap $q$", fontsize = fontsize, labelpad = 15)
    
    fig_axis.set_xlabel(r"Load $\alpha$", fontsize = fontsize, labelpad = 15)
    plt.tight_layout()
    plt.show()