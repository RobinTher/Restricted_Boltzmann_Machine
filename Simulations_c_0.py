import numpy as np
import torch
import gc
from Restricted_Boltzmann_machine_training import RBM

import matplotlib.pyplot as plt

plt.rcParams["font.family"] = "serif"
plt.rcParams["mathtext.fontset"] = "dejavuserif"

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
'''
beta = 1.2

n_alpha = 20
alpha_range = np.linspace(0.1, 2, num = n_alpha, endpoint = True) # np.array([1.])

N = 512
P = 2
m_0 = 0.2

# It is very fast to sample from the teacher
number_teacher_sampling_steps = 1000
number_monitored_sampling_steps = 0

number_student_training_epochs = 36*12000
number_monitored_training_epochs = 5
number_burn_in_epochs = 108000
number_magnetization_samples = 500

random_number_seed = 2

random_batch_seed = 87

field_magnitude = 0.04
'''

def simulation_run(beta, alpha_range, N, P, m_0, number_teacher_sampling_steps,
                    number_monitored_sampling_steps, number_student_training_epochs,
                    number_monitored_training_epochs, number_burn_in_epochs,
                    number_magnetization_samples, random_number_seed,
                    random_batch_seed, field_magnitude = 0.):
    '''
    Train a binary student RBM on data generated by a binary teacher RBM for a range of loads alpha
    in order to reproduce Fig. (3).
    The teacher and student have the same number of visible units N and hidden units P.
    See Restricted_Boltzmann_machine_training.py for the definition of the RBM class
    and the inputs of this function.
    The results are saved in .npy files.
    '''
    n_alpha = len(alpha_range)

    random_number_generator = torch.Generator(device = device)
    random_number_generator.manual_seed(random_number_seed)

    random_batch_generator = torch.Generator(device = "cpu")
    random_batch_generator.manual_seed(random_batch_seed)

    teacher = RBM(N, P, device = device, random_number_generator = random_number_generator,
                random_batch_generator = random_batch_generator).to(device)
    xi_s = teacher.initialize_weights(1., xi_0 = None, binarize = True)

    field = field_magnitude * xi_s

    student = RBM(N, P, device = device, random_number_generator = random_number_generator,
                random_batch_generator = random_batch_generator, teacher = teacher).to(device)
    student.initialize_weights(m_0, xi_0 = xi_s, P = P, binarize = True, bias_corner = False)

    m_mean_range = np.zeros(n_alpha)
    m_std_range = np.zeros(n_alpha)

    for i, alpha in enumerate(alpha_range):
        M = int(alpha*N)
        beta_eff = beta/N**(1/2)
        
        N_batch_size = 1
        
        sigma = torch.nn.Parameter(torch.sign(torch.randn((M, N), device = device, generator = random_number_generator)), requires_grad = False)
        
        teacher.gibbs_sample_visible(sigma, beta_eff, number_teacher_sampling_steps, number_monitored_sampling_steps)
        
        m_list = student.metropolis_training(sigma, field, beta_eff, number_student_training_epochs, N_batch_size, number_monitored_training_epochs,
                                            number_burn_in_epochs, number_magnetization_samples, anneal = False)
        
        m_range = np.abs(np.array(m_list))
        
        m_main_diag = np.diagonal(m_range, axis1 = 1, axis2 = 2)
        
        m_mean_range[i] = np.mean(m_main_diag)
        m_std_range[i] = np.std(m_main_diag)
        
        del sigma
        
        # Reinitialize weights
        student.initialize_weights(m_0, xi_0 = xi_s, P = P, binarize = True, bias_corner = False)

    with open("./Data/simulated_magnetization_P=%d_beta=%.2f.npy" % (P, beta), "wb") as file:
        np.save(file, m_mean_range)
        np.save(file, m_std_range)

    del teacher
    del student

    gc.collect()

def plot_simulated_overlap(beta, alpha_range, P, c = None):
    '''
    Load the magnetization from .npy files written by the function simulation_run
    and compare it to the prediction of the saddle-point equations in order to reproduce Fig. (3).
    '''
    fontsize = 13
    
    if c is None:
        with open("./Data/PSB_magnetization_P=%d_beta=%.2f.npy" % (P, beta), "rb") as file:
            m_range = np.load(file)
        
        with open("./Data/simulated_PSB_magnetization_P=%d_beta=%.2f.npy" % (P, beta), "rb") as file:
            m_mean_range = np.load(file)
            m_std_range = np.load(file)
    else:
        # May need to change the path
        with open("./Data/magnetization_c=%.2f_P=%d_beta=%.2f.npy" % (c, P, beta), "rb") as file:
            m_range = np.load(file)
        
        with open("./Data/simulated_magnetization_c=%.2f_P=%d_beta=%.2f.npy" % (c, P, beta), "rb") as file:
            m_mean_range = np.load(file)
            m_std_range = np.load(file)
    
    plt.errorbar(alpha_range, m_mean_range, m_std_range, marker = "o", linestyle = "--", capsize = 3, zorder = 2.5, color = "C0")
    plt.plot(alpha_range, m_range, color = "C1")
    plt.xlabel(r"Load $\alpha$", fontsize = fontsize)
    plt.ylabel(r"Magnetization $m$", fontsize = fontsize)
    plt.xticks(fontsize = fontsize)
    plt.yticks(fontsize = fontsize)
    plt.tight_layout()
    plt.show()